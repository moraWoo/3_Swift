Для хранения объектов Swift использует две структуры данных: стек и куча.
Управление распределением памяти:
  - выделение памяти под объект (аллокацию)
  - ее последующее высвобождение (деаллокацию)
Модели управления памяти:
  - MRC (retain и release для сохранения объекта в памяти и его последующего высвобождения)
  - ARC

В swift с ARC мы в основном используем ссылки:
  - strong (сильные)
  - weak (слабые)
  - unowned

Жизненный цикл объекта:
  - Выделение памяти (аллокация): берет память из стека или кучи.
  - Инициализация: выполняется init-код
  - Эксплуатация: объект используется
  - Деинициализация: выполняется deinit-код
  - Высвобождение памяти (деаллокация): память возвращается стеку или куче обратно.

Проблемы в рамках управления памятью:
  - Освобождение или перезапись данных, когда объект еще используется. Это вызывает сбой или повреждение данных
  - Объект не высвобожден, когда он уже не используется. Это приводит к утечке памяти
  - Сбои в приложении

Утечка памяти (memory leak)
  Объект не будет использоваться, но занимает память. Когда два объекта ссылаются друг на друга.

Два объекта имеют ненулевой счетчик ссылок ---> оба ссылаются друг на друга --> не возможно деаллоцировать их --> утечка памяти "memory leak" --> "retain cycle" (цикл сохранения)

weak: не увеличивает счетчик ссылок(RC). является optional. когда RC=0 объект будет деаллоцирован.
unowned: не увеличивает RC. не optional. Если вы попытаетесь получить доступ к unowned свойству, которое ссылается на деинициализированный объект, вы получите ошибку времени выполнения, сравнимую с принудительной распаковкой необязательного типа с nil.

       | var | let | optional | non-optional |
strong |  +  |  +  |     +    |      +       |
weak   |  +  |  -  |     +    |      -       |
unowned|  +  |  +  |     -    |      +       |

Цикл сохранения сильных ссылок в замыканиях:
Когда вы используете замыкания (closures) внутри экземпляра класса, они потенциально могут захватить self. Если self, в свою очередь, сохраняет это замыкание, у вас будет взаимный цикл сохранения сильных ссылок между замыканием и экземпляром класса.

Чтобы избежать этого, вы должны использовать те же самые ключевые слова weak и unowned в списке захвата (capture list) замыкания.
p1.load = { [weak p1]
  p1?.department = getDepName()
}

# stack & heap
Swift автоматически выделяет память либо в куче, либо в стеке.

"stack"
- статическое выделение памяти, во время компиляции
- стуктура LIFO (последний вошел, первый вышел)
- очень быстрый доступ
- функция вызывается, локальные экземпляры этой функции будут помещены в стек. Как только функция совершит возврат, все экземпляры будут удалены из стека.
- данные в стэке, находятся там временно, пока функция не завершит работу и не вызовет авто высвобождение памяти.
- каждая область видимости (scope) в вашем приложении предоставит необходимый объем памяти.
- стек не используется с объектами, которые имеют переменный размер.
- каждый поток имеет свой стек
- в стеке хранятся типы: стурктуры и перечисления.
- Если размер вашего типа значения может быть определен во время компиляции или если ваш тип значения не содержит рекурсивно/не содержится в ссылочном типе, тогда он будет требовать аллокации в стеке.
- Тип-значение не увеличивает счетчик ссылок. Но если ваш тип-значение содержит внутренние ссылки, его копирование потребует увеличения счетчика ссылок его дочерних элементов.

"heap"
- динамическое выделение памяти во время рантайма
- к значениям можно обрашаться в любое время по адресу памяти
- нет ограничений на размер памяти
- более медленный доступ
- когда процесс запрашивает определенный объем памяти, куча ищет адрес памяти, который удовлетваряет запросу и возвращает его процессу
- когда память больше не используется, процесс должен указать динамической памяти о высвобождении этого раздела памяти.
- требует потокобезопасности
- куча совместно используется всем чем угодно
- Если размер вашего типа значения не может быть определен во время компиляции (из-за протокола/общего требования), или если ваш тип значения рекурсивно содержит/содержится ссылочным типом (помните, что замыкания также являются ссылочными типами), то потребуется выделение в куче.
- класс хранится в куче

Аллокация в куче медленнее, чем аллокация в стеке не только из-за более сложной структуры данных — она также требует потокобезопасности. Каждый поток имеет свой собственный стек, но куча используется совместно всем, что требует синхронизации.
