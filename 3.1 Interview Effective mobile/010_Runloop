#runloop
https://stevenpcurtis.medium.com/what-is-a-runloop-anyway-swift-and-ios-guide-aa574577331b

RunLoop (Цикл запуска) - Run Loop (цикл исполнения) является механизмом, который позволяет потокам обрабатывать события (events) бесконечно в любое время.

RunLoop запускается автоматически при запуске приложения и работает до тех пор, пока приложение не завершит свою работу. RunLoop может быть запущен в нескольких режимах, каждый из которых представляет собой набор разрешенных и необходимых источников событий.

Когда приложение начинает работу, RunLoop получает события из источников событий, например, из пользовательского интерфейса (например, касания экрана), сетевого соединения или таймеров, и определяет, какой код должен быть выполнен в ответ на эти события. Если событие не происходит, RunLoop переводит приложение в состояние ожидания, чтобы избежать использования излишних ресурсов процессора.

RunLoop работает в тесной связке с потоками. Каждый поток имеет свой RunLoop, который отвечает за обработку событий, связанных с этим потоком. Если поток не имеет запущенного RunLoop, то он не может обрабатывать события.

RunLoop в Swift может быть использован, например, для обработки пользовательского ввода, выполнения фоновой загрузки данных из сети, управления анимацией или обновления пользовательского интерфейса. Он является важной концепцией для разработчиков приложений, работающих на платформе iOS и macOS.

func startRunLoop() {
    let thread = Thread.current
    let runLoop = RunLoop.current
    runLoop.run()
}

Этот код запускает RunLoop в текущем потоке и блокирует его выполнение, пока не будет вызван метод stop() объекта RunLoop.

RunLoop не запускается автоматически при создании потока, поэтому его нужно запустить вручную, если это необходимо.

Когда вы создаете новый поток в приложении, новый экземпляр RunLoop автоматически создается для этого потока, но он не будет запущен, пока вы явно не вызовете метод run() объекта RunLoop.

Если вы не запустите RunLoop, то поток не будет обрабатывать события, связанные с ним, такие как пользовательский ввод или сетевые запросы.

Кроме того, если поток не имеет запущенного RunLoop, попытки отправки сообщений или уведомлений могут привести к блокировке потока или даже к сбою приложения.

Поэтому важно запускать RunLoop в каждом потоке, когда это необходимо.

Запуск нескольких RunLoop может быть полезен в некоторых случаях, когда вы хотите обрабатывать различные типы событий в разных потоках или когда вам нужно иметь более точный контроль над обработкой событий в конкретных потоках.

Кроме того, использование нескольких RunLoop может помочь вам более точно контролировать обработку событий в конкретных потоках. Вы можете настроить RunLoop, чтобы он работал в определенный период времени или остановить его в любое время, когда это необходимо. Это может быть полезно для управления временем выполнения задач в потоке или для принудительной остановки потока в случае необходимости.

В целом, использование нескольких RunLoop может быть полезным для улучшения производительности и отзывчивости приложения в зависимости от его конкретных потребностей.

RunLoop имеет несколько состояний, которые определяют, что происходит в данный момент с RunLoop и как он обрабатывает события. Рассмотрим каждое состояние более подробно:

1. "Initialized"
2. "Running"
3. "Waiting"
4. "Stopped"
5. "Finishing"

1. "Initialized"
Это начальное состояние RunLoop, когда он только что был создан и еще не начал обрабатывать события.

2. "Running"
RunLoop находится в этом состоянии, когда его метод run() вызван. В этом состоянии RunLoop обрабатывает события и уведомления, которые были добавлены в очередь RunLoop.

3. "Waiting"
Если в очереди RunLoop нет никаких событий, то он переходит в режим ожидания. В этом состоянии RunLoop ожидает появления новых событий или уведомлений, чтобы продолжить обработку.

4. "Stopped"
Когда метод stop() вызван для RunLoop, он переходит в это состояние. В этом состоянии RunLoop не обрабатывает никаких событий и завершает свою работу.

5. "Finishing"
RunLoop находится в этом состоянии, когда он заканчивает обработку всех событий в очереди и готовится к завершению своей работы.

6. "Cancelled"
Это состояние RunLoop, когда он был отменен. Например, если поток, в котором запущен RunLoop, был принудительно остановлен.

Каждое из этих состояний может быть полезно в различных сценариях. Например, вы можете использовать состояние "Waiting" для уменьшения нагрузки на процессор, когда в очереди RunLoop нет событий, а состояние "Stopped" для остановки RunLoop, когда он больше не нужен

Run loop делает две вещи

- ожидает пока что-то не произойдёт.
- отправляет сообщение к получателю.

Несколько интересных моментов про таймер

- runloop к которому ты добавляешь таймер держит на него сильную ссылку (то есть тебе не обязательно локально складывать таймер в strong property).
- Таймер ретейнит свой таргет (тот у которого он будет вызывать селектор).
- запуск в бекграунде. Селектор таймера не вызывается т. к. на background queue другой ранлуп
- интересный момент про таймер, чтобы запустить его не на мейн потоке надо сперва стартануть ранлуп
- scheduledTimerWithTimeInterval добавляет таймер в существующий ранлуп главного треда, не надо ничего стартовать
