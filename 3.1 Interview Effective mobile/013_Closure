#closure

Замыкание (closure) в Swift - это самостоятельная функция, которая может быть передана и использована как любой другой объект, такой как переменная или аргумент функции.

- у замыкания нет имени
- нет именнованных параметров

Замыкание в Swift имеет следующий синтаксис:
{(parameters) -> returnType in
    // код замыкания
}
где parameters - список параметров, returnType - тип возвращаемого значения и in - ключевое слово, разделяющее заголовок и тело замыкания.

Есть три вида клоужеров
  - глобальные функции, имеют имя и не захватывают значения
  - вложенные функции, имеют имя и захватывают значения внутри области функции
  - безимянные функции

Для чего? Упростить синтаксис нашей программы.
// функция
func add(a: Int, b: Int) -> Int {
  return a + b
}
// клоужер
var addVar: (Int, Int) -> Int = { a, b in
  return a + b
}

add(a: 3, b: 5)
addVar(5, 3)

var addVar: (Int, Int) -> Int = { $0 + $1 }

func myFunc(a:Int, b: Int, mathFunc: (Int, Int) -> Int) {
  let result = mathFunc(a,b)
  print(result)
}
// передаем функцию или клоужер в другую функцию
myFunc(a: 5, b: 3, mathFunc: addVar)

myFunc(a: 5, b: 3, mathFunc: { $0 - $1 })
// если последний параметр это клоужер то можно скобку передвинуть
// trail annotation
myFunc(a: 5, b: 3) { $0 - $1 }

#autoclosure

// если добавить ключевое слово @autoclosure, то код при вызове функции будет обернут в замыкание

func autoclosureFunc(isOk: Bool, closure: @autoclosure () -> Void) {
  if isOk {
    closure()
  } else {
    print("sorry")
  }
}
autoclosureFunc(isOk: true, closure: print("My closure"))

Автозамыкание - это не что иное, как синтаксическое удобство для написания более чистого кода.
Иногда синтаксически удобно использовать autoclosure при работе с функцией, которая принимает аргумент замыкания.
Это происходит потому, что autoclosure позволяет не использовать фигурные скобки {}.

# захват значений
var integer = 5 // 5
// замыкание захватывает значение integer
var someClosure = {
  integer += 1
}
someClosure() // 6
integer += 1 // 7
someClosure() // 8

// замыкание может захватывать значение например integer, но он только копирует его себе, значение захватываемое значение (integer) в closure неизменяемое.
// (a,b,c) это параметры замыкания.
var someClosure = { [integer] a,b,c in
  print(integer)
}
// можно добавить alias
var someClosure = { [number = integer] a,b,c in
  print(number)
}
someClosure() // он скопировал себе значение 5 и распечатал
integer += 1 // теперь оригинальная переменная стала вместо 5 - 6.
someClosure() // но в замыкании уже есть скопированное значение и это 5
print("last print - \(integer)") // распечатывает оригинальное значение переменной, но уже измененное, т.е. 6.

#escaping

В Swift, замыкание (closure) по умолчанию является незахватывающим (non-escaping) и выполняется в контексте функции, в которой оно было создано. Однако в некоторых случаях замыкание может использоваться вне контекста функции, в которой оно было создано. Для этого замыкание должно быть помечено атрибутом @escaping.

@escaping указывает на то, что замыкание может выполняться после выхода из функции, в которой оно было создано. Это означает, что замыкание может быть захвачено другим объектом и сохранено для выполнения в будущем, например, как обработчик завершения (completion handler).

Рассмотрим пример:
func getData(completion: @escaping (String) -> Void) {
    DispatchQueue.global().async {
        let data = "Some data"
        completion(data)
    }
}

В этом примере мы объявили функцию getData, которая принимает замыкание completion с атрибутом @escaping. Затем мы запускаем асинхронную операцию в глобальной очереди и, когда операция завершится, вызываем замыкание completion с полученными данными.

Без атрибута @escaping компилятор не позволит нам использовать замыкание completion за пределами функции getData, так как замыкание должно быть выполнено до выхода из функции.

Таким образом, использование @escaping позволяет передавать замыкания за пределы функции и выполнять их в будущем. Отличие от обычного замыкания заключается в том, что @escaping замыкание может быть сохранено для выполнения в будущем, тогда как обычное замыкание выполняется только в контексте функции, в которой оно было создано.

Completion handlers (обработчики завершения) — это замыкания в действии. Предположим, вы выполняете трудоемкую задачу, например сетевой запрос, и хотите что-то сделать сразу после завершения запроса.

Но вы определенно не хотите тратить ресурсы впустую, проверяя несколько раз, продолжается ли процесс или нет. Здесь используются обработчики завершения. Обработчик завершения — это замыкание, которое «вернется» сразу после завершения трудоемкого процесса. Узнайте больше о замыканиях и о том, как передать функцию в качестве параметра.
