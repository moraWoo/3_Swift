#dispatching

Диспетчеризация в Swift — это механизм, который определяет, какой код будет выполнен в ответ на вызов метода или свойства. Диспетчеризация необходима, когда у нас есть объекты, имеющие одинаковые методы или свойства, но они реализованы по-разному в разных контекстах.

Swift поддерживает два вида диспетчеризации:

Compile-time (статическая диспетчеризация): метод или свойство, которые вызываются, определяются на этапе компиляции, основываясь на типе объекта, на котором они вызываются. Это означает, что компилятор Swift может оптимизировать код, так как он знает, какой именно метод или свойство будет вызван.

Диспетчеризация на этапе компиляции:
enum Shape {
    case rectangle(width: Double, height: Double)
    case square(side: Double)
    case circle(radius: Double)

    func area() -> Double {
        switch self {
        case let .rectangle(width, height):
            return width * height
        case let .square(side):
            return side * side
        case let .circle(radius):
            return Double.pi * radius * radius
        }
    }
}

let shape = Shape.rectangle(width: 5, height: 10)
let area = shape.area()
print(area) // Выведет 50
В этом примере, метод area() диспетчеризуется на этапе компиляции, так как тип Shape известен на этапе компиляции, а также компилятор может определить вызываемый метод на основе ключевого слова switch.

Runtime (динамическая диспетчеризация): метод или свойство, которые вызываются, определяются во время выполнения программы, основываясь на реальном типе объекта, на котором они вызываются. Это означает, что компилятор Swift не может оптимизировать код на этапе компиляции.


Диспетчеризация на рантайме:
class Animal {
    func speak() {
        print("...")
    }
}

class Dog: Animal {
    override func speak() {
        print("Woof!")
    }
}

class Cat: Animal {
    override func speak() {
        print("Meow!")
    }
}

let animal1 = Animal()
let animal2 = Dog()
let animal3 = Cat()

let animals: [Animal] = [animal1, animal2, animal3]

for animal in animals {
    animal.speak()
}

В этом примере, метод speak() диспетчеризуется на рантайме, так как тип объекта animal определяется на основе конкретного объекта в массиве animals. Таким образом, при вызове метода speak(), рантайм определяет, какой метод использовать в зависимости от типа объекта. Если тип объекта - Animal, то будет вызван метод speak() из класса Animal, если тип - Dog, то будет вызван метод speak() из класса Dog, и т.д.

Существует два типа методов диспетчеризации в Swift: статическая (compile-time) и динамическая (runtime).

Статическая диспетчеризация происходит на этапе компиляции и выбор вызываемого метода определяется на основе типа переменной (или константы), которой он принадлежит. Это означает, что если у вас есть переменная типа Animal, которая на самом деле содержит объект типа Dog, и вы вызываете метод speak на этой переменной, то будет вызван метод speak класса Animal, а не класса Dog.

Динамическая диспетчеризация, с другой стороны, происходит на этапе выполнения программы. Это означает, что выбор вызываемого метода происходит на основе реального типа объекта, а не типа переменной. Если в примере выше переменная была бы объявлена как тип Dog, то вызов метода speak на этой переменной вызвал бы метод speak класса Dog.

Динамическая диспетчеризация более гибкая, так как позволяет изменять поведение объектов во время выполнения программы. Однако это также более затратно с точки зрения производительности, чем статическая диспетчеризация, так как требует дополнительных проверок и поиска подходящих методов во время выполнения.

Концепция диспетчеризации относится к тому, как компилятор и интерпретатор определяют, какой код должен быть выполнен для вызова метода или функции. Статическая диспетчеризация определяется во время компиляции, а динамическая диспетчеризация - во время выполнения программы.

Статическая диспетчеризация происходит в тех случаях, когда компилятор может точно определить, какой метод или функция должна быть вызвана, и генерирует соответствующий код во время компиляции. Это более эффективно, чем динамическая диспетчеризация, но менее гибко.

Динамическая диспетчеризация происходит в тех случаях, когда компилятор не может точно определить, какой метод или функция должна быть вызвана, и генерирует код, который определяет это во время выполнения программы. Это более гибко, чем статическая диспетчеризация, но менее эффективно.
