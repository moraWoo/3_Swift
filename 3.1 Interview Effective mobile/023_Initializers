#initilizers

Инициализатор (initializer) в Swift - это специальный метод, который используется для инициализации экземпляра класса, структуры или перечисления до его первого использования. Он вызывается при создании нового объекта и используется для установки начальных значений свойств объекта.

Синтаксис инициализатора выглядит следующим образом:
init(parameters) {
    // код инициализатора
}
где parameters - список параметров, которые необходимо передать при создании объекта.

Рассмотрим пример:
class Person {
    var name: String
    var age: Int

    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}

let john = Person(name: "John", age: 30)

New chat
Autoclosures in Swift.


Flutter app with Get
Виски с древесным вкусом
Buy iOS app ≠ free Android app
GetX Flutter Library
Протоколы Swift. Назначение.
Подсветка Swift в VS Code.
Функция и ее определение.
Swift multithreading interview.
Swift Operations Framework
iOS Interview Prep
Pros & Cons of Trees
Opaque типы в Swift
SwiftLint Rules Summary
Сборка iOS из VSCode
SwiftLint конфигурация правил
Picker с ошибкой.
SwiftLint в Xcode.
Git: 1 approving review.
Optional Binding в SignUpAssembly.

Show more
Clear conversations
Upgrade to Plus
NEW
Dark mode
Get help
Log out

ildar.khabibullin.kz@gmail.com
Расскажи про autoclosure в swift
В Swift есть возможность использовать автозамыкание (autoclosure) для отложенного вычисления выражения, которое будет передано в функцию в качестве аргумента.

Автозамыкание - это оптимизация, которая позволяет передать выражение в функцию без явного использования замыканий. При использовании автозамыканий, выражение будет вычислено только в тот момент, когда оно будет вызвано внутри функции.

Для объявления автозамыкания в Swift используется ключевое слово @autoclosure. Рассмотрим пример:

less
Copy code
func printResult(_ getResult: @autoclosure () -> Int) {
    print("Result is \(getResult())")
}

printResult(2 + 2)
В этом примере мы определили функцию printResult, которая принимает автозамыкание типа () -> Int в качестве аргумента. Затем мы вызываем эту функцию, передавая ей выражение 2 + 2.

Выражение 2 + 2 будет автоматически обернуто в автозамыкание благодаря аннотации @autoclosure. Когда это выражение будет вызвано внутри функции printResult, оно будет вычислено, и результат будет напечатан.

Таким образом, использование автозамыканий может упростить код и улучшить производительность в случаях, когда необходимо передавать аргументы в функцию, которые не должны быть вычислены, пока они не будут действительно использоваться внутри функции.




ildar.khabibullin.kz@gmail.com
что такое @escaping и чем отличается от обычного closure
В Swift, замыкание (closure) по умолчанию является незахватывающим (non-escaping) и выполняется в контексте функции, в которой оно было создано. Однако в некоторых случаях замыкание может использоваться вне контекста функции, в которой оно было создано. Для этого замыкание должно быть помечено атрибутом @escaping.

@escaping указывает на то, что замыкание может выполняться после выхода из функции, в которой оно было создано. Это означает, что замыкание может быть захвачено другим объектом и сохранено для выполнения в будущем, например, как обработчик завершения (completion handler).

Рассмотрим пример:

less
Copy code
func getData(completion: @escaping (String) -> Void) {
    DispatchQueue.global().async {
        let data = "Some data"
        completion(data)
    }
}
В этом примере мы объявили функцию getData, которая принимает замыкание completion с атрибутом @escaping. Затем мы запускаем асинхронную операцию в глобальной очереди и, когда операция завершится, вызываем замыкание completion с полученными данными.

Без атрибута @escaping компилятор не позволит нам использовать замыкание completion за пределами функции getData, так как замыкание должно быть выполнено до выхода из функции.

Таким образом, использование @escaping позволяет передавать замыкания за пределы функции и выполнять их в будущем. Отличие от обычного замыкания заключается в том, что @escaping замыкание может быть сохранено для выполнения в будущем, тогда как обычное замыкание выполняется только в контексте функции, в которой оно было создано.




ildar.khabibullin.kz@gmail.com
что такое closure
Замыкание (closure) в Swift - это самостоятельная функция, которая может быть передана и использована как любой другой объект, такой как переменная или аргумент функции.

Замыкание может захватывать значения из внешнего контекста, где оно было определено. Это означает, что замыкание может использовать переменные и константы, которые были определены в области видимости функции, где замыкание было создано, даже после того, как функция завершила свое выполнение.

Замыкание в Swift имеет следующий синтаксис:

rust
Copy code
{(parameters) -> returnType in
    // код замыкания
}
где parameters - список параметров, returnType - тип возвращаемого значения и in - ключевое слово, разделяющее заголовок и тело замыкания.

Рассмотрим пример:

scss
Copy code
let greeting = {
    print("Hello, world!")
}

greeting()
В этом примере мы определили замыкание greeting, которое не принимает аргументов и не возвращает значений. Затем мы вызываем это замыкание, используя скобки (). Вызов замыкания приводит к печати строки "Hello, world!".

Замыкания в Swift могут быть переданы как аргументы функции и возвращены из функций, что делает их мощным инструментом для работы с функциями высшего порядка и асинхронными операциями.




ildar.khabibullin.kz@gmail.com
расскажи про инициализаторы в swift по проще и подробнее
Инициализатор (initializer) в Swift - это специальный метод, который используется для инициализации экземпляра класса, структуры или перечисления до его первого использования. Он вызывается при создании нового объекта и используется для установки начальных значений свойств объекта.

Синтаксис инициализатора выглядит следующим образом:

javascript
Copy code
init(parameters) {
    // код инициализатора
}
где parameters - список параметров, которые необходимо передать при создании объекта.

Рассмотрим пример:

swift
Copy code
class Person {
    var name: String
    var age: Int

    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}

let john = Person(name: "John", age: 30)
В этом примере мы определили класс Person, у которого есть свойства name и age, а также инициализатор, который принимает два параметра name и age. Внутри инициализатора мы устанавливаем значения свойств name и age.

Затем мы создаем экземпляр класса Person с именем john, используя инициализатор и передавая ему значения name и age.

В Swift существует несколько типов инициализаторов:

1. Дефолтный инициализатор - инициализатор без параметров, который создается автоматически, если в классе или структуре не определен ни один инициализатор.

Дефолтный инициализатор в Swift автоматически создается компилятором для всех структур и классов, которые не имеют пользовательских инициализаторов. Он имеет следующий вид:
init() {}

Этот инициализатор просто создает новый объект со всеми свойствами, установленными в их значения по умолчанию. Если свойства имеют числовые типы, то они устанавливаются в 0, если это булево значение, то в false, а если это опциональное значение или класс, то оно устанавливается в nil.

Вот пример использования дефолтного инициализатора для класса Person:
class Person {
    var name: String
    var age: Int

    // Дефолтный инициализатор
    init() {
        name = ""
        age = 0
    }
}

let person = Person() // Создание объекта с помощью дефолтного инициализатора

Обратите внимание, что в примере мы задаем значения свойствам name и age вручную в теле дефолтного инициализатора. Это необходимо, потому что в противном случае компилятор не сможет определить, какие значения следует установить для свойств, которые не имеют явно заданных значений по умолчанию.

2. Инициализаторы с параметрами - как в примере выше, определяются вручную и принимают значения для инициализации свойств объекта.

3. Failable инициализаторы - инициализаторы, которые могут вернуть nil в случае, если объект не может быть корректно инициализирован. Обычно используется для проверки входных данных.

struct Temperature {
    var celsius: Double

    init?(fahrenheit: Double) {
        if fahrenheit < -459.67 {
            return nil
        }
        celsius = (fahrenheit - 32) * 5 / 9
    }
}

let boilingPoint = Temperature(fahrenheit: 212) // создание объекта Temperature
let absoluteZero = Temperature(fahrenheit: -500) // инициализация может вернуть nil, так как значение -500 некорректно

В этом примере мы определяем структуру Temperature, которая представляет температуру в градусах Цельсия. Мы создаем failable инициализатор, который принимает значение температуры в градусах Фаренгейта и конвертирует его в градусы Цельсия. Если значение в градусах Фаренгейта меньше, чем абсолютный ноль (-459,67), инициализатор возвращает nil, в противном случае возвращает новый объект Temperature с установленным значением в градусах Цельсия.

4. Convenience инициализаторы - инициализаторы, которые предоставляют дополнительный уровень удобства или функциональности, например, для установки дефолтных значений свойств.
Инициализаторы в Swift являются важной частью процесса создания объектов и могут быть использованы для проверки корректности данных и настройки объектов до их использования.

struct Point {
    var x: Double
    var y: Double

    init(x: Double, y: Double) {
        self.x = x
        self.y = y
    }

    init(randomInRange range: ClosedRange<Double>) {
        x = Double.random(in: range)
        y = Double.random(in: range)
    }
}

let origin = Point(x: 0, y: 0)
let randomPoint = Point(randomInRange: -1...1)

В этом примере мы определяем структуру Point, которая представляет точку на двумерной плоскости. Мы создаем конструктор init(randomInRange:), который устанавливает случайные значения координат точки в заданном диапазоне. Это удобный инициализатор, который предоставляет дополнительный уровень удобства и функциональности для создания случайных точек в заданном диапазоне значений.

Обратите внимание, что для использования метода Double.random(in:), который используется в этом примере, необходимо использовать Swift 5.1 и выше. Если вы используете более ранние версии Swift, то для генерации случайных чисел можно использовать другие методы, например arc4random_uniform().

Надеюсь, примеры помогут лучше понять различные типы инициализаторов в Swift.

#initializers in structs
В структурах инициализаторы могут быть чуть более гибкими, потому что они могут иметь параметры по умолчанию и использовать ключевое слово mutating, если необходимо изменять свойства структуры внутри инициализатора. Вот пример структуры Rectangle с пользовательским инициализатором:

struct Rectangle {
    var width: Double
    var height: Double

    init(width: Double = 0.0, height: Double = 0.0) {
        self.width = width
        self.height = height
    }

    mutating func doubleSize() {
        width *= 2
        height *= 2
    }
}

В этом примере мы определили пользовательский инициализатор для структуры Rectangle, который принимает два параметра с значением по умолчанию. Мы также добавили метод doubleSize(), который умножает ширину и высоту на 2 с помощью ключевого слова mutating. Этот метод меняет свойства структуры Rectangle напрямую, поэтому мы должны использовать mutating.

Важно отметить, что в классах инициализаторы могут иметь различные модификаторы доступа, например public, private или internal, которые определяют, кто может использовать эти инициализаторы. В структурах инициализаторы по умолчанию имеют модификатор доступа internal, но вы можете изменить его на любой другой модификатор доступа, который вам нужен.

#initializers in enum
enum CompassPoint {
    case north, south, east, west

    init?(direction: String) {
        switch direction.lowercased() {
        case "north":
            self = .north
        case "south":
            self = .south
        case "east":
            self = .east
        case "west":
            self = .west
        default:
            return nil
        }
    }
}
Этот пример enum представляет четыре направления, которые можно использовать для указания направления. Инициализатор init?(direction: String) принимает строковое значение, которое указывает направление, и инициализирует enum соответствующим значением. Если передано недопустимое значение, инициализатор возвращает nil.

Этот инициализатор можно использовать следующим образом:
if let direction = CompassPoint(direction: "north") {
    print("The direction is \(direction)")
} else {
    print("Invalid direction")
}

Здесь мы пытаемся инициализировать enum CompassPoint с помощью инициализатора init?(direction: String). Если направление действительно существует, то мы печатаем его значение. Если направление недопустимо, мы печатаем "Invalid direction".
