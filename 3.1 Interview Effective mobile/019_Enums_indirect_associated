# associated values
Удобно хранить ассоциативные значения других типов вместе с этими значениями кейсов перечисления.

Это позволяет вам хранить дополнительную пользовательскую информацию вместе со значением кейса и разрешает изменять эту информацию каждый раз как вы используете этот кейс перечисления в вашем коде.

enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}

Объявление перечисления типа Barcode, которое берет два значения, одно из которых upc, с ассоциативным значением типа (Int, Int, Int, Int) и значение qrCode с ассоциативным значением типа String.

var productBarcode = Barcode.upc(8, 85909, 51226, 3)
productBarcode = .qrCode("ABCDEFGHIJKLMNOP")


# indirect enums

В Swift, indirect enums – это перечисления, использующие индиректные ссылки на свои собственные значения, что позволяет создавать рекурсивные структуры данных. Индиректность полезна, когда значения перечисления могут содержать экземпляры самого перечисления, создавая бесконечную цепочку вложенных элементов.

Если одно из кейсов перечисления содержит ассоциированное значение типа самого перечисления, вы должны пометить это значение или все перечисление ключевым словом "indirect".

Пример с использованием indirect на уровне перечисления:
indirect enum BinaryTree {
    case leaf(Int)
    case node(BinaryTree, Int, BinaryTree)
}

let left = BinaryTree.leaf(5)
let right = BinaryTree.leaf(8)
let root = BinaryTree.node(left, 12, right)

Здесь мы определяем indirect enum BinaryTree, который может быть либо листом с целочисленным значением, либо узлом с двумя ветками (левой и правой), которые также являются экземплярами BinaryTree. Используя ключевое слово indirect, мы разрешаем рекурсивное вложение значений перечисления.

Вместо того чтобы использовать indirect на уровне всего перечисления, вы также можете применить его к отдельным кейсам:
enum BinaryTree {
    case leaf(Int)
    indirect case node(BinaryTree, Int, BinaryTree)
}

let left = BinaryTree.leaf(5)
let right = BinaryTree.leaf(8)
let root = BinaryTree.node(left, 12, right)

В этом примере мы используем ключевое слово indirect только для кейса node, что позволяет создавать рекурсивные структуры данных с вложенными значениями перечисления. Здесь root – это узел дерева, содержащий две ветви, left и right, каждая из которых является листом с целочисленными значениями.

Теперь у нас есть полное дерево:
      12
     /  \
    5    8
С использованием indirect enums, мы можем легко создавать и работать с рекурсивными структурами данных, такими как деревья и связные списки, используя вложенные значения перечисления.
