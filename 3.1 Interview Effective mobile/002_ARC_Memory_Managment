# ARC, stack, heap

https://habr.com/ru/companies/otus/articles/649329/
https://habr.com/ru/companies/hh/articles/546856/

Для хранения объектов Swift использует две структуры данных: стек и куча.
Управление распределением памяти:
  - выделение памяти под объект (аллокацию)
  - ее последующее высвобождение (деаллокацию)

Модели управления памяти:
  - MRC (retain и release для сохранения объекта в памяти и его последующего высвобождения)
  - ARC (расстановку функций alloc(создаем ссылку), retain(+1), release(-1), dealloc(0) компилятор делает сам, а подсчет ссылок идет в рантайме)

"retain cycle" (цикл сильных ссылок провоцирует утечку памяти) - когда объекты ссылаются сами на себя, но никто более не ссылается.
Пример. Parent-child. Родитель имеет ссылку на дочерние элементы, а дочерние элементы имеют ссылку на родителя. Рекомендуется ссылку на родителя делать weak ссылкой.

В swift с ARC мы в основном используем ссылки:
  - strong (сильные)
  - weak (слабые)
  - unowned

"strong" - пока у кого-то есть сильная ссылка на объект, этот объект будет существовать в куче. По умолчанию для всех свойств, констант и переменных.

"weak" - ссылка на объект в куче. Не учитывается в подсчете ссылок, и явяляется optional. Когда объект освобождается из памяти "weak" ссылка устанавливается на nil.

"unowned" - ссылка на объект в куче. Не учитывается в подсчете ссылок. Когда объект освнобождается из памяти и если обратиться к экземпляру по "unowned" ссылке, приложение упадет.

Жизненный цикл объекта:
"Live" – объект создан и делает какие-то полезные вещи.
"Deiniting" – объект находится в процессе деинициализации, то есть у него вызван метод deinit.
"Deinited" – объект полность деинициализирован.
"Freed" – выделенная память под объект освобождена, но side table еще существует.
"Dead" – память занятая side table освобождается.

Объект живет пока на него есть "strong" ссылки. И хотя счетчик "strong" ссылок инициализируется нулем, считается, что на объект есть одна ссылка. Он ссылается сам на себя. Ведь действительно на него еще никто не сослался, но и умирать ему рано. Для изменения значения счетчика strong ссылок используются функции "swift_retain" и "swift_release". Функция "swift_retain" инкрементирует, а "swift_release" декрементирует значение счетчика. Компилятор генерирует вызовы этих функций в нужных местах.

Если у объекта нет side table
  - Если количество unowned ссылок равно нулю, тогда объект сразу переходит в состояние dead.
  - А если unowned ссылки есть, тогда объект переходит в состояние deinited.

Если у объекта есть side table
  - Если количество unowned ссылок равно нулю, тогда объект переходит в состояние freed.
  - А если unowned ссылки есть, тогда объект переходит в состояние deinited.

Если у объекта нет side table и в какой-то момент количество unowned ссылок на него станет равным нулю, тогда он из состояния deinited перейдет в состояние dead. В состоянии dead память под объект освобождается.  Для наглядности лучше представить жизненный цикл объекта без side table в виде схемы:

Проблемы в рамках управления памятью:
  - Освобождение или перезапись данных, когда объект еще используется. Это вызывает сбой или повреждение данных
  - Объект не высвобожден, когда он уже не используется. Это приводит к утечке памяти
  - Сбои в приложении

Утечка памяти (memory leak)
  Объект не будет использоваться, но занимает память. Когда два объекта ссылаются друг на друга.

Два объекта имеют ненулевой счетчик ссылок ---> оба ссылаются друг на друга --> не возможно деаллоцировать их --> утечка памяти "memory leak" --> "retain cycle" (цикл сохранения)

"weak": не увеличивает счетчик ссылок(RC). является optional. когда RC=0 объект будет деаллоцирован.
"unowned": не увеличивает RC. не optional. Если вы попытаетесь получить доступ к unowned свойству, которое ссылается на деинициализированный объект, вы получите ошибку времени выполнения, сравнимую с принудительной распаковкой необязательного типа с nil.

       | var | let | optional | non-optional |
strong |  +  |  +  |     +    |      +       |
weak   |  +  |  -  |     +    |      -       |
unowned|  +  |  +  |     -    |      +       |

Цикл сохранения сильных ссылок в замыканиях:
Когда вы используете замыкания (closures) внутри экземпляра класса, они потенциально могут захватить self. Если self, в свою очередь, сохраняет это замыкание, у вас будет взаимный цикл сохранения сильных ссылок между замыканием и экземпляром класса.

Чтобы избежать этого, вы должны использовать те же самые ключевые слова weak и unowned в списке захвата (capture list) замыкания.
p1.load = { [weak p1]
  p1?.department = getDepName()
}

# stack & heap
Swift автоматически выделяет память либо в куче, либо в стеке.

"stack"
- статическое выделение памяти, во время компиляции
- стуктура LIFO (последний вошел, первый вышел)
- очень быстрый доступ
- функция вызывается, локальные экземпляры этой функции будут помещены в стек. Как только функция совершит возврат, все экземпляры будут удалены из стека.
- данные в стэке, находятся там временно, пока функция не завершит работу и не вызовет авто высвобождение памяти.
- каждая область видимости (scope) в вашем приложении предоставит необходимый объем памяти.
- стек не используется с объектами, которые имеют переменный размер.
- каждый поток имеет свой стек
- в стеке хранятся типы: стурктуры и перечисления.
- Если размер вашего типа значения может быть определен во время компиляции или если ваш тип значения не содержит рекурсивно/не содержится в ссылочном типе, тогда он будет требовать аллокации в стеке.
- Тип-значение не увеличивает счетчик ссылок. Но если ваш тип-значение содержит внутренние ссылки, его копирование потребует увеличения счетчика ссылок его дочерних элементов.

"heap"
- динамическое выделение памяти во время рантайма
- к значениям можно обрашаться в любое время по адресу памяти
- нет ограничений на размер памяти
- более медленный доступ
- когда процесс запрашивает определенный объем памяти, куча ищет адрес памяти, который удовлетваряет запросу и возвращает его процессу
- когда память больше не используется, процесс должен указать динамической памяти о высвобождении этого раздела памяти.
- требует потокобезопасности
- куча совместно используется всем чем угодно
- Если размер вашего типа значения не может быть определен во время компиляции (из-за протокола/общего требования), или если ваш тип значения рекурсивно содержит/содержится ссылочным типом (помните, что замыкания также являются ссылочными типами), то потребуется выделение в куче.
- класс хранится в куче

Аллокация в куче медленнее, чем аллокация в стеке не только из-за более сложной структуры данных — она также требует потокобезопасности. Каждый поток имеет свой собственный стек, но куча используется совместно всем, что требует синхронизации.
