#static
static - это ключевое слово в Swift, которое используется для объявления статических свойств и методов класса или структуры. Статические свойства и методы относятся к самому типу, а не к экземпляру этого типа, и могут быть использованы без создания экземпляра.

Свойства и методы, объявленные как static, могут использоваться в том же контексте, что и имя типа, в котором они объявлены. Например, мы можем создать структуру SomeStructure с статическим свойством storedProperty и статическим методом someTypeMethod:
struct SomeStructure {
    static var storedProperty = "Some value."

    static func someTypeMethod() {
        print("This is a type method.")
    }
}

Здесь мы используем ключевое слово static для объявления статического свойства storedProperty и статического метода someTypeMethod(). Мы можем использовать эти свойства и методы, обращаясь к типу SomeStructure, а не к экземпляру структуры. Например:
print(SomeStructure.storedProperty) // "Some value."
SomeStructure.storedProperty = "Another value."
print(SomeStructure.storedProperty) // "Another value."

SomeStructure.someTypeMethod() // "This is a type method."

Здесь мы обращаемся к статическому свойству storedProperty и статическому методу someTypeMethod() через тип SomeStructure, а не через экземпляр структуры.

Стоит отметить, что статические свойства и методы могут использоваться и для классов. Однако, в отличие от структур, классы могут иметь и свойства и методы типа (type properties and methods), которые являются аналогом статических свойств и методов, но могут быть переопределены в подклассах с помощью ключевого слова class.

Если мы хотим обратиться к свойству или методу структуры, которые не являются статическими, мы должны сначала создать экземпляр структуры, а затем обратиться к его свойствам или методам через точку:
struct SomeStructure {
    var instanceProperty = "Some value."

    func someInstanceMethod() {
        print("This is an instance method.")
    }
}

var structure = SomeStructure()
print(structure.instanceProperty) // "Some value."
structure.instanceProperty = "Another value."
print(structure.instanceProperty) // "Another value."

structure.someInstanceMethod() // "This is an instance method."
Здесь мы создаем экземпляр структуры SomeStructure с помощью пустого инициализатора, затем обращаемся к его свойству instanceProperty и изменяем его значение. Затем мы вызываем метод someInstanceMethod(), который также принадлежит экземпляру структуры, а не типу. Обратите внимание, что мы не используем ключевое слово static, потому что свойство и метод не являются статическими.

Хотя использование static может быть удобным для объявления статических свойств и методов, оно также имеет свои минусы:

1. Ограничения на наследование и полиморфизм: в отличие от свойств и методов, объявленных без ключевого слова static, статические свойства и методы не могут быть переопределены в подклассах. Это может ограничить возможности наследования и полиморфизма в вашем коде.

2. Проблемы с тестированием: статические свойства и методы не могут быть заменены на макеты или заглушки (mocks или stubs) во время тестирования. Это может затруднить написание автоматических тестов для вашего кода.

3. Проблемы с потокобезопасностью: если статические свойства и методы используются в многопоточной среде, это может привести к проблемам с потокобезопасностью. Например, если несколько потоков пытаются изменить статическое свойство одновременно, это может привести к гонкам данных (data races) и другим проблемам.

4. Сложность отладки: статические свойства и методы могут быть вызваны из любого места вашего кода, что может сделать отладку сложнее. Если статическое свойство или метод используется во многих местах, это может усложнить выявление причин ошибок.

В целом, использование static может быть удобным для определенных случаев, когда вам нужны статические свойства и методы, но необходимо быть осторожным, чтобы не создать новых проблем с потокобезопасностью, наследованием и тестированием. В некоторых случаях может быть полезно использовать более гибкие альтернативы, такие как свойства и методы экземпляра или свойства и методы типа с возможностью переопределения в подклассах с помощью ключевого слова class.
