#closure

Замыкание (closure) в Swift - это самостоятельная функция, которая может быть передана и использована как любой другой объект, такой как переменная или аргумент функции.

Замыкание может захватывать значения из внешнего контекста, где оно было определено. Это означает, что замыкание может использовать переменные и константы, которые были определены в области видимости функции, где замыкание было создано, даже после того, как функция завершила свое выполнение.

Замыкание в Swift имеет следующий синтаксис:
{(parameters) -> returnType in
    // код замыкания
}

где parameters - список параметров, returnType - тип возвращаемого значения и in - ключевое слово, разделяющее заголовок и тело замыкания.

Рассмотрим пример:
let greeting = {
    print("Hello, world!")
}

greeting()

В этом примере мы определили замыкание greeting, которое не принимает аргументов и не возвращает значений. Затем мы вызываем это замыкание, используя скобки (). Вызов замыкания приводит к печати строки "Hello, world!".

Замыкания в Swift могут быть переданы как аргументы функции и возвращены из функций, что делает их мощным инструментом для работы с функциями высшего порядка и асинхронными операциями.

#autoclosure

Автозамыкание - это не что иное, как синтаксическое удобство для написания более чистого кода.
Иногда синтаксически удобно использовать autoclosure при работе с функцией, которая принимает аргумент замыкания.
Это происходит потому, что autoclosure позволяет не использовать фигурные скобки {}.



Для объявления автозамыкания в Swift используется ключевое слово @autoclosure. Рассмотрим пример:

func printResult(_ getResult: @autoclosure () -> Int) {
    print("Result is \(getResult())")
}

printResult(2 + 2)

В этом примере мы определили функцию printResult, которая принимает автозамыкание типа () -> Int в качестве аргумента. Затем мы вызываем эту функцию, передавая ей выражение 2 + 2.

Выражение 2 + 2 будет автоматически обернуто в автозамыкание благодаря аннотации @autoclosure. Когда это выражение будет вызвано внутри функции printResult, оно будет вычислено, и результат будет напечатан.



Вот пример того, как autoclosure упрощает код. В первом фрагменте используется обычное замыкание, а во втором - autoclosure. Посмотрите, как вызов функции I_will стал более читабельным во втором фрагменте:

func iWill(_ perform_action: () -> Void) {
  performAction()
}

iWill({
  print("Hello, world!")
})

func iWill(_ perform_action: @autoclosure () -> Void) {
    performAction()
}

iWill(print("Hello, world"))

#escaping

В Swift, замыкание (closure) по умолчанию является незахватывающим (non-escaping) и выполняется в контексте функции, в которой оно было создано. Однако в некоторых случаях замыкание может использоваться вне контекста функции, в которой оно было создано. Для этого замыкание должно быть помечено атрибутом @escaping.

@escaping указывает на то, что замыкание может выполняться после выхода из функции, в которой оно было создано. Это означает, что замыкание может быть захвачено другим объектом и сохранено для выполнения в будущем, например, как обработчик завершения (completion handler).

Рассмотрим пример:
func getData(completion: @escaping (String) -> Void) {
    DispatchQueue.global().async {
        let data = "Some data"
        completion(data)
    }
}

В этом примере мы объявили функцию getData, которая принимает замыкание completion с атрибутом @escaping. Затем мы запускаем асинхронную операцию в глобальной очереди и, когда операция завершится, вызываем замыкание completion с полученными данными.

Без атрибута @escaping компилятор не позволит нам использовать замыкание completion за пределами функции getData, так как замыкание должно быть выполнено до выхода из функции.

Таким образом, использование @escaping позволяет передавать замыкания за пределы функции и выполнять их в будущем. Отличие от обычного замыкания заключается в том, что @escaping замыкание может быть сохранено для выполнения в будущем, тогда как обычное замыкание выполняется только в контексте функции, в которой оно было создано.

Completion handlers (обработчики завершения) — это замыкания в действии. Предположим, вы выполняете трудоемкую задачу, например сетевой запрос, и хотите что-то сделать сразу после завершения запроса.

Но вы определенно не хотите тратить ресурсы впустую, проверяя несколько раз, продолжается ли процесс или нет. Здесь используются обработчики завершения. Обработчик завершения — это замыкание, которое «вернется» сразу после завершения трудоемкого процесса. Узнайте больше о замыканиях и о том, как передать функцию в качестве параметра.
